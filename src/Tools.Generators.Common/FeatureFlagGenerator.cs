using System.Text;
using System.Xml;
using Common.Extensions;
using Common.FeatureFlags;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Tools.Generators.Common;

/// <summary>
///     A source generator for converting <see cref="FeatureFlags" /> to feature flag values
/// </summary>
[Generator]
public class FeatureFlagGenerator : ISourceGenerator
{
    private const string Filename = "FeatureFlags\\Flag.g.cs";

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var assemblyNamespace = $"{typeof(Flag).Namespace}";
        var classUsingNamespaces = $"using {typeof(Flag).Namespace};";

        var fileSource = BuildFile(context, assemblyNamespace, classUsingNamespaces, context.CancellationToken);

        context.AddSource(Filename, SourceText.From(fileSource, Encoding.UTF8));

        return;

        static Dictionary<string, string> GetFlagResources(GeneratorExecutionContext context,
            CancellationToken cancellationToken)
        {
            var resourceFile = context.AdditionalFiles
                .FirstOrDefault(af => af.Path.EndsWith(".resx"));
            if (resourceFile is null)
            {
                return new Dictionary<string, string>();
            }

            var xml = resourceFile.GetText(cancellationToken)!;
            var xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(xml.ToString());
            var root = xmlDocument.DocumentElement!;

            var values = root.SelectNodes("/root/data")!
                .Cast<XmlNode>()
                .Select(node =>
                {
                    var name = node.Attributes!["name"].Value;
                    var value = node.SelectSingleNode("value")?.InnerText;
                    return new KeyValuePair<string, string>(name, value ?? name);
                });

            return values.ToDictionary(pair => pair.Key, pair => pair.Value);
        }

        static string BuildFlagDefinitions(Dictionary<string, string> flags)
        {
            var builder = new StringBuilder();
            const string className = nameof(Flag);
            foreach (var flag in flags)
            {
                builder.AppendFormat($"    public static {className} {{0}} = new {className}(\"{{1}}\");", flag.Key,
                    flag.Value.ToSnakeCase());
                builder.AppendLine();
            }

            return builder.ToString();
        }

        static string BuildFile(GeneratorExecutionContext context, string assemblyNamespace,
            string allUsingNamespaces, CancellationToken cancellationToken)
        {
            const string className = nameof(Flag);
            var allFlags = GetFlagResources(context, cancellationToken);
            var flagDefinitions = BuildFlagDefinitions(allFlags);

            return $@"// <auto-generated/>
{allUsingNamespaces}

namespace {assemblyNamespace};

/// <inheritdoc cref=""{className}"" />
partial class {className}
{{
{flagDefinitions}
}}
";
        }
    }
}